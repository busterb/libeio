.\" Automatically generated by Pod::Man 2.16 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "LIBEIO 3"
.TH LIBEIO 3 "2008-05-11" "libeio-1.0" "libeio - truly asynchronous POSIX I/O"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
libev \- a high performance full\-featured event loop written in C
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #include <ev.h>
.Ve
.Sh "\s-1EXAMPLE\s0 \s-1PROGRAM\s0"
.IX Subsection "EXAMPLE PROGRAM"
.Vb 2
\&  // a single header file is required
\&  #include <ev.h>
\&
\&  // every watcher type has its own typedef\*(Aqd struct
\&  // with the name ev_<type>
\&  ev_io stdin_watcher;
\&  ev_timer timeout_watcher;
\&
\&  // all watcher callbacks have a similar signature
\&  // this callback is called when data is readable on stdin
\&  static void
\&  stdin_cb (EV_P_ struct ev_io *w, int revents)
\&  {
\&    puts ("stdin ready");
\&    // for one\-shot events, one must manually stop the watcher
\&    // with its corresponding stop function.
\&    ev_io_stop (EV_A_ w);
\&
\&    // this causes all nested ev_loop\*(Aqs to stop iterating
\&    ev_unloop (EV_A_ EVUNLOOP_ALL);
\&  }
\&
\&  // another callback, this time for a time\-out
\&  static void
\&  timeout_cb (EV_P_ struct ev_timer *w, int revents)
\&  {
\&    puts ("timeout");
\&    // this causes the innermost ev_loop to stop iterating
\&    ev_unloop (EV_A_ EVUNLOOP_ONE);
\&  }
\&
\&  int
\&  main (void)
\&  {
\&    // use the default event loop unless you have special needs
\&    struct ev_loop *loop = ev_default_loop (0);
\&
\&    // initialise an io watcher, then start it
\&    // this one will watch for stdin to become readable
\&    ev_io_init (&stdin_watcher, stdin_cb, /*STDIN_FILENO*/ 0, EV_READ);
\&    ev_io_start (loop, &stdin_watcher);
\&
\&    // initialise a timer watcher, then start it
\&    // simple non\-repeating 5.5 second timeout
\&    ev_timer_init (&timeout_watcher, timeout_cb, 5.5, 0.);
\&    ev_timer_start (loop, &timeout_watcher);
\&
\&    // now wait for events to arrive
\&    ev_loop (loop, 0);
\&
\&    // unloop was called, so exit
\&    return 0;
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The newest version of this document is also available as an html-formatted
web page you might find easier to navigate when reading it for the first
time: <http://cvs.schmorp.de/libev/ev.html>.
.PP
Libev is an event loop: you register interest in certain events (such as a
file descriptor being readable or a timeout occurring), and it will manage
these event sources and provide your program with events.
.PP
To do this, it must take more or less complete control over your process
(or thread) by executing the \fIevent loop\fR handler, and will then
communicate events via a callback mechanism.
.PP
You register interest in certain events by registering so-called \fIevent
watchers\fR, which are relatively small C structures you initialise with the
details of the event, and then hand it over to libev by \fIstarting\fR the
watcher.
.Sh "\s-1FEATURES\s0"
.IX Subsection "FEATURES"
Libev supports \f(CW\*(C`select\*(C'\fR, \f(CW\*(C`poll\*(C'\fR, the Linux-specific \f(CW\*(C`epoll\*(C'\fR, the
BSD-specific \f(CW\*(C`kqueue\*(C'\fR and the Solaris-specific event port mechanisms
for file descriptor events (\f(CW\*(C`ev_io\*(C'\fR), the Linux \f(CW\*(C`inotify\*(C'\fR interface
(for \f(CW\*(C`ev_stat\*(C'\fR), relative timers (\f(CW\*(C`ev_timer\*(C'\fR), absolute timers
with customised rescheduling (\f(CW\*(C`ev_periodic\*(C'\fR), synchronous signals
(\f(CW\*(C`ev_signal\*(C'\fR), process status change events (\f(CW\*(C`ev_child\*(C'\fR), and event
watchers dealing with the event loop mechanism itself (\f(CW\*(C`ev_idle\*(C'\fR,
\&\f(CW\*(C`ev_embed\*(C'\fR, \f(CW\*(C`ev_prepare\*(C'\fR and \f(CW\*(C`ev_check\*(C'\fR watchers) as well as
file watchers (\f(CW\*(C`ev_stat\*(C'\fR) and even limited support for fork events
(\f(CW\*(C`ev_fork\*(C'\fR).
.PP
It also is quite fast (see this
benchmark comparing it to libevent
for example).
.Sh "\s-1CONVENTIONS\s0"
.IX Subsection "CONVENTIONS"
Libev is very configurable. In this manual the default (and most common)
configuration will be described, which supports multiple event loops. For
more info about various configuration options please have a look at
\&\fB\s-1EMBED\s0\fR section in this manual. If libev was configured without support
for multiple event loops, then all functions taking an initial argument of
name \f(CW\*(C`loop\*(C'\fR (which is always of type \f(CW\*(C`struct ev_loop *\*(C'\fR) will not have
this argument.
.Sh "\s-1TIME\s0 \s-1REPRESENTATION\s0"
.IX Subsection "TIME REPRESENTATION"
Libev represents time as a single floating point number, representing the
(fractional) number of seconds since the (\s-1POSIX\s0) epoch (somewhere near
the beginning of 1970, details are complicated, don't ask). This type is
called \f(CW\*(C`ev_tstamp\*(C'\fR, which is what you should use too. It usually aliases
to the \f(CW\*(C`double\*(C'\fR type in C, and when you need to do any calculations on
it, you should treat it as some floatingpoint value. Unlike the name
component \f(CW\*(C`stamp\*(C'\fR might indicate, it is also used for time differences
throughout libev.
.SH "GLOBAL FUNCTIONS"
.IX Header "GLOBAL FUNCTIONS"
These functions can be called anytime, even before initialising the
library in any way.
.IP "ev_tstamp ev_time ()" 4
.IX Item "ev_tstamp ev_time ()"
Returns the current time as libev would use it. Please note that the
\&\f(CW\*(C`ev_now\*(C'\fR function is usually faster and also often returns the timestamp
you actually want to know.
.IP "ev_sleep (ev_tstamp interval)" 4
.IX Item "ev_sleep (ev_tstamp interval)"
Sleep for the given interval: The current thread will be blocked until
either it is interrupted or the given time interval has passed. Basically
this is a subsecond-resolution \f(CW\*(C`sleep ()\*(C'\fR.
.IP "int ev_version_major ()" 4
.IX Item "int ev_version_major ()"
.PD 0
.IP "int ev_version_minor ()" 4
.IX Item "int ev_version_minor ()"
.PD
You can find out the major and minor \s-1ABI\s0 version numbers of the library
you linked against by calling the functions \f(CW\*(C`ev_version_major\*(C'\fR and
\&\f(CW\*(C`ev_version_minor\*(C'\fR. If you want, you can compare against the global
symbols \f(CW\*(C`EV_VERSION_MAJOR\*(C'\fR and \f(CW\*(C`EV_VERSION_MINOR\*(C'\fR, which specify the
version of the library your program was compiled against.
.Sp
These version numbers refer to the \s-1ABI\s0 version of the library, not the
release version.
.Sp
Usually, it's a good idea to terminate if the major versions mismatch,
as this indicates an incompatible change. Minor versions are usually
compatible to older versions, so a larger minor version alone is usually
not a problem.
.Sp
Example: Make sure we haven't accidentally been linked against the wrong
version.
.Sp
.Vb 3
\&  assert (("libev version mismatch",
\&           ev_version_major () == EV_VERSION_MAJOR
\&           && ev_version_minor () >= EV_VERSION_MINOR));
.Ve
.IP "unsigned int ev_supported_backends ()" 4
.IX Item "unsigned int ev_supported_backends ()"
Return the set of all backends (i.e. their corresponding \f(CW\*(C`EV_BACKEND_*\*(C'\fR
value) compiled into this binary of libev (independent of their
availability on the system you are running on). See \f(CW\*(C`ev_default_loop\*(C'\fR for
a description of the set values.
.Sp
Example: make sure we have the epoll method, because yeah this is cool and
a must have and can we have a torrent of it please!!!11
.Sp
.Vb 2
\&  assert (("sorry, no epoll, no sex",
\&           ev_supported_backends () & EVBACKEND_EPOLL));
.Ve
.IP "unsigned int ev_recommended_backends ()" 4
.IX Item "unsigned int ev_recommended_backends ()"
Return the set of all backends compiled into this binary of libev and also
recommended for this platform. This set is often smaller than the one
returned by \f(CW\*(C`ev_supported_backends\*(C'\fR, as for example kqueue is broken on
most BSDs and will not be autodetected unless you explicitly request it
(assuming you know what you are doing). This is the set of backends that
libev will probe for if you specify no backends explicitly.
.IP "unsigned int ev_embeddable_backends ()" 4
.IX Item "unsigned int ev_embeddable_backends ()"
Returns the set of backends that are embeddable in other event loops. This
is the theoretical, all-platform, value. To find which backends
might be supported on the current system, you would need to look at
\&\f(CW\*(C`ev_embeddable_backends () & ev_supported_backends ()\*(C'\fR, likewise for
recommended ones.
.Sp
See the description of \f(CW\*(C`ev_embed\*(C'\fR watchers for more info.
.IP "ev_set_